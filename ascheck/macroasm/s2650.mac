.IF	DEF,.$$.S2650

.IIF	NDEF,.$$.LIST	.NLIST	;DO NO LIST THE MACRO TABLES
	;DURING CHECKOUT DEFINE .$$.LIST TO ENABLE LISTING
.IIF	DEF,.$$.LIST	.LIST
	;
	;
.IIF	DEF,.$$.LIST	.TITLE	SIGNETICS 2650 CROSS-ASSEMBLER
	;
.IIF	DEF,.$$.LIST	.SBTTL	CROSS ASSEMBLER INTRODUCTION
	;
	;****************************************************************
	;*								*
	;*	MACRO PACKAGE FOR SIGNETICS 2650 MICRO-PROCESSOR	*
	;*	  TO RUN UNDER MACRO 11.				*
	;*								*
	;*	BY BRUCE FILGATE OF COMPONENTS GROUP ENGINEERING	*
	;*	  DIGITAL EQUIPMENT CORPORATION, MARLBORUGH MA.		*
	;*								*
	;*		SEPTEMBER 8, 1976				*
	;*								*
	;*								*
	;*								*
	;*	UPDATED BY ALAN R. BALDWIN  - JULY 1979			*
	;*								*
	;****************************************************************
	;****************************************************************
	;*								*
	;*	REWRITTEN FOR THE ASXXXX 'ASCHECK' ASSEMBLER		*
	;*								*
	;*		DECEMBER 2008					*
	;*								*
	;****************************************************************
	;
	;	THIS IS AN ABSOLUTE CROSS ASSEMBLER. I.E. ALL
	;	ADDRESSES ARE CONSIDERED ABSOLUTE AND NOT RELOCATABLE.
	;
	;			!!! WARNING !!!
	;	RELOCATING THE CODE USING THE LINKER RELOCATION
	;	OPTIONS WILL 'NOT' RELOCATE THE CODE CORRECTLY.
	;

.IIF	DEF,.$$.LIST	.PAGE
	;
	;THE FOLLOWING DIFFERENCES EXIST BETWEEN THIS CROSS ASSEMBLER AND
	;THE SIGNETICS ASSEMBLER DOCUMENTED IN THEIR MANUAL FOR THE 2650.
	;	LABELS MUST TERMINATE WITH A :
	;	COMMENTS START WITH A ;
	;	INDIRECT ADDRESSING IS DENOTED BY A SEPARATE ARGUMENT @
	;
	;DEFINITION OF ASSEMBLER DIRECTIVES WITH DIFFERENCES
	;	END -  USE	.END	END OF PROGRAM
	;	EQU -  USE  	=	EQUATE SYMBOL
	;	FCB -  USE	.FCB	FORM SINGLE-BYTE CONSTANT
	;	FCC -  USE	.FCC	FORM CONSTANT CHARACTERS
	;	FDB -  USE	.FDB	FORM DOUBLE-BYTE CONSTANT
	;	MON -  NOT IMPLEMENTED	RETURN TO MONITOR CONSOLE
	;	NAM -  USE	.SBTTL	PROGRAM NAME
	;	OPT -  NOT IMPLEMENTED	OPTION
	;	ORG -  USE	.ORG	ORIGIN
	;	PAGE - USE	.PAGE	ADVANCE LISTING TO TOP OF PAGE
	;	RMB -  USE	.RMB	RESERVE MEMORY BYTES
	;	SPC -  NOT IMPLEMENTED	SPACE N LINES
	;
.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	CONDITION CODES AND STATUS
	;
	;CONDITION FLAG TESTS
	;	EQ	TRUE IF COMPARISON GAVE A ZERO RESULT
	;	LT	TRUE IF COMPARISON GAVE A NEGATIVE RESULT
	;	GT	TRUE IF COMPARISON GAVE A POSITVE RESULT
	;	UN	UNCONDITIONAL TRUE
	;
	;PROGRAM STATUS LOWER
	;	BIT MAP	7   6   5   4   3   2   1   0
	;	FUNCTION	CC1 CC0 IDC RS  WC  OVF COM C
	;	C	CARRY/BORROW
	;	COM	1=LOGICAL COMPARE, 0=ARITHMETIC COMPARE
	;	OVF	OVERFLOW BIT
	;	WC	1=WITH CARRY, 0=WITHOUT CARRY
	;	RS	1 FOR R4,R5,R6    0 FOR R1,R2,R3
	;	IDC	BCD INTERDIGIT CARRY
	;	CC0	1=POSITIVE RESULT, 0=NON POSITIVE RESULT
	;	CC1	1=NEGATIVE RESULT, 0=NON NEGATIVE RESULT
	;
	;
	;PROGRAM STATUS UPPER
	;	BIT MAP	7   6   5   4   3   2   1   0
	;	FUNCTION	S   F   II         SP2 SP1 SP0
	;	SP0	STACK POINTER
	;	SP1	  "      "
	;	SP2	  "      "
	;	II	INTERRUPT INHIBIT
	;	F	OUTPUT FLAG (PIN #40)
	;	S	SENSE INPUT (PIN #1)  READ/ONLY


.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	LOCAL VARIABLES
	;
	.LOCAL	...A,	...REG,	...TYP,	...NARG
	.LOCAL	...IND,	...IDX,	...IMM
	;
	;
	;BYTE ORDERING IS HI ... LO
	;
	.HILO
	;
	;
	;CONSTANTS ARE IN OCTAL
	;
	;
.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	REGISTER MACROS

.MACRO	.$.REG	R,E
 ...REG = -0Q1
 .IIF	IDN	^!R!,r0		...REG = 0Q0
 .IIF	IDN	^!R!,r1		...REG = 0Q1
 .IIF	IDN	^!R!,r2		...REG = 0Q2
 .IIF	IDN	^!R!,r3		...REG = 0Q3
 .IIF	IDN	^!R!,R0		...REG = 0Q0
 .IIF	IDN	^!R!,R1		...REG = 0Q1
 .IIF	IDN	^!R!,R2		...REG = 0Q2
 .IIF	IDN	^!R!,R3		...REG = 0Q3
 .IF	NB,^!E!
  .IIF	LT,...REG	.ERROR	1	;INVALID REGISTER
  ...REG = ...REG & 0Q3
 .ENDIF
.ENDM	;.$.REG

.MACRO	.$.REGM	R,E
 ...REG = -0Q1
 .IIF	IDN	^!R!,-r0	...REG = 0Q0
 .IIF	IDN	^!R!,-r1	...REG = 0Q1
 .IIF	IDN	^!R!,-r2	...REG = 0Q2
 .IIF	IDN	^!R!,-r3	...REG = 0Q3
 .IIF	IDN	^!R!,-R0	...REG = 0Q0
 .IIF	IDN	^!R!,-R1	...REG = 0Q1
 .IIF	IDN	^!R!,-R2	...REG = 0Q2
 .IIF	IDN	^!R!,-R3	...REG = 0Q3
 .IF	NB,^!E!
  .IIF	LT,...REG	.ERROR	1	;INVALID REGISTER
  ...REG = ...REG & 0Q3
 .ENDIF
.ENDM	;.$.REGM

.MACRO	.$.REGP	R,E
 ...REG = -0Q1
 .IIF	IDN	^!R!,+r0	...REG = 0Q0
 .IIF	IDN	^!R!,+r1	...REG = 0Q1
 .IIF	IDN	^!R!,+r2	...REG = 0Q2
 .IIF	IDN	^!R!,+r3	...REG = 0Q3
 .IIF	IDN	^!R!,+R0	...REG = 0Q0
 .IIF	IDN	^!R!,+R1	...REG = 0Q1
 .IIF	IDN	^!R!,+R2	...REG = 0Q2
 .IIF	IDN	^!R!,+R3	...REG = 0Q3
 .IF	NB,^!E!
  .IIF	LT,...REG	.ERROR	1	;INVALID REGISTER
  ...REG = ...REG & 0Q3
 .ENDIF
.ENDM	;.$.REGP

.MACRO	.$.REGIDX		X
 .IF	NE,...REG
  .ERROR	1	;R0 IS THE ONLY ALLOWED DESTINATION REGISTER
 .ENDIF
 .$.REGP	X
 .IF		GE,...REG
  ...IDX = 0Q40
 .ELSE
  .$.REGM	X
  .IF	GE,...REG
   ...IDX = 0Q100
  .ELSE
   .$.REG	X
   .IF		GE,...REG
    ...IDX = 0Q140
   .ELSE
    ...REG = 0Q0
    .ERROR	1	;INVALID REGISTER
   .ENDIF
  .ENDIF
 .ENDIF
.ENDM	;.$.REGIDX

.MACRO	.$.CON		X,Y
 ...CON = -0Q1
 .IIF IDN ^!X!,eq	...CON = 0Q0
 .IIF IDN ^!X!,gt	...CON = 0Q1
 .IIF IDN ^!X!,lt	...CON = 0Q2
 .IIF IDN ^!X!,un	...CON = 0Q3
 .IIF IDN ^!X!,EQ	...CON = 0Q0
 .IIF IDN ^!X!,GT	...CON = 0Q1
 .IIF IDN ^!X!,LT	...CON = 0Q2
 .IIF IDN ^!X!,UN	...CON = 0Q3
 .IF	LT,...CON
  .IIF	NB,^!Y!		.ERROR	1	;INVALID CONDITIONAL
  ...CON = 0Q3
 .ENDIF
.ENDM	;.$.CON

.MACRO	.$.IND	X,Y
 ...IND = -0Q1
 .IIF IDN ^!X!,@	...IND = 0Q200
 .IF	LT,...IND
  .IIF	NB,^!Y!		.ERROR	1	;INVALID INSTRUCTION
  ...IND = 0Q0
 .ENDIF
.ENDM	;.$.IND

.MACRO	.$.IMM		I
 .NTYP	...TYP,I
 .IF	EQ,...TYP
  ...IMM = I
 .ELSE
  .NVAL	...IMM,I
 .ENDIF
.ENDM	;.$.IMM

.MACRO	.$.REL		I
 .NTYP	...TYP,I
 .IF	EQ,...TYP
  .NVAL	...REL,I
  ...REL = I - ...REL - 0Q2
 .ELSE
  ...REL = I - . - 0Q2
 .ENDIF
 .IIF	LT,...REL + 0Q100	.ERROR	1	;BRANCH OUT OF RANGE
 .IIF	GE,...REL - 0Q100	.ERROR	1	;BRANCH OUT OF RANGE
 ...REL = ...REL & 0Q177
.ENDM	;.$.REL


.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	SIMPLE ONE BYTE INSTRUCTIONS

;SIMPLE ONE BYTE INSTRUCTIONS,EG:	LPSU

.MACRO	.$.$.$	A,B
 .MACRO	A
  .BYTE	B
 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	LPSU,		0Q222	;LOAD PROGRAM STATUS,UPPER
.$.$.$	LPSL,		0Q223	;LOAD PROGRAM STATUS,LOWER
.$.$.$	SPSU,		0Q22	;STORE PROGRAM STATUS, UPPER
.$.$.$	SPSL,		0Q23	;STORE PROGRAM STATUS, LOWER
.$.$.$	NOP,		0Q300
.$.$.$	HALT,		0Q100
.$.$.$	WAIT,		0Q100

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	ONE BYTE REGISTER INSTRUCTIONS

;ONE BYTE REGISTER INSTRUCTIONS,EG:	ADDZ	R1

.MACRO	.$.$.$	A,B
 .MACRO	A	X
 .$.REG	X,ERROR
 .BYTE	B + ...REG
 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	ADDZ,		0Q200	;ADD TO R0, W/WO CARRY
.$.$.$	SUBZ,		0Q240	;SUBTRACT FROM R0, W/WO BORROW
.$.$.$	IORZ,		0Q140	;INCLUSIVE OR TO R0
.$.$.$	EORZ,		0Q40	;EXCLUSIVE OR TO R0
.$.$.$	COMZ,		0Q340	;COMPARE TO R0, ARITHMETIC/LOGICAL
.$.$.$	CMPZ,		0Q340	;COMPARE TO R0, ARITHMETIC/LOGICAL
.$.$.$	RRL,		0Q320	;ROTATE REGISTER LEFT, W/WO CARRY
.$.$.$	RRR,		0Q120	;ROTATE REGISTER RIGHT, W/WO CARRY
.$.$.$	REDD,		0Q160	;READ DATA
.$.$.$	REDC,		0Q60	;READ CONTROL
.$.$.$	WRTD,		0Q360	;WRITE DATA
.$.$.$	WRTC,		0Q260	;WRITE CONTROL
.$.$.$	DAR,		0Q224	;DECIMAL ADJUST REGISTER

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	NON R0 ONE BYTE REGISTER INSTRUCTIONS

;SPECIAL CASE ONE BYTE REGISTER (NOT R0) INSTRUCTIONS,EG:	ANDZ	R1
.MACRO	.$.$.$	A,B
 .MACRO	A	X
 .$.REG	X,ERROR
 .IF EQ,...REG
  .IF NE,B
   .ERROR	1	;R0 IS ILLEGAL
   .BYTE B + 0Q1
  .ELSE
   .BYTE 0Q140
  .ENDIF
 .ELSE
  .BYTE B + ...REG
 .ENDIF
 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	ANDZ,		0Q100	;AND TO R0, R NOT R0
.$.$.$	LODZ,		0Q0	;LOAD R0
.$.$.$	STRZ,		0Q300	;STORE R0, R NOT R0

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	TWO BYTE REGISTER INSTRUCTIONS

;TWO BYTE REGISTER INSTRUCTIONS,EG:.	LODI	R3,VALUE

.MACRO	.$.$.$	A,B
 .MACRO	A	X,Y
 .$.REG	X,ERROR
 .$.IMM	Y
 .BYTE	B + ...REG,...IMM
 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OPCODE
.$.$.$	LODI,		0Q4	;LOAD IMMEDIATE
.$.$.$	ADDI,		0Q204	;ADD IMMEDIATE W/WO CARRY
.$.$.$	SUBI,		0Q244	;SUBTRACT IMMEDIATE W/WO BORROW
.$.$.$	ANDI,		0Q104	;AND IMMEDIATE
.$.$.$	IORI,		0Q144	;INCLUSIVE OR IMMEDIATE
.$.$.$	EORI,		0Q44	;EXCLUSIVE OR IMMEDIATE
.$.$.$	COMI,		0Q344	;COMPARE IMMEDIATE ARITHMETIC/LOGICAL
.$.$.$	CMPI,		0Q344	;COMPARE IMMEDIATE ARITHMETIC/LOGICAL
.$.$.$	REDE,		0Q124	;READ EXTENDED
.$.$.$	WRTE,		0Q324	;WRITE EXTENDED
.$.$.$	TMI,		0Q364	;TEST UNDER MASK IMMEDIATE

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	STATUS WORD INSTRUCTIONS

;STATUS WORD INSTRUCTIONS,EG:	PPSU	MASK

.MACRO	.$.$.$	A,B
 .MACRO	A	X
 .$.IMM		X
 .BYTE	B,...IMM
 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	PPSU,		0Q166	;PRESET PROGRAM STATUS UPPER, MASKED
.$.$.$	PPSL,		0Q167	;PRESET PROGRAM STATUS LOWER, MASKED
.$.$.$	CPSU,		0Q164	;CLEAR PROGRAM STATUS UPPER, MASKED
.$.$.$	CPSL,		0Q165	;CLEAR PROGRAM STATUS LOWER, MASKED
.$.$.$	TPSU,		0Q264	;TEST PROGRAM STATUS UPPER, MASKED
.$.$.$	TPSL,		0Q265	;TEST PROGRAM STATUS LOWER, MASKED

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	RETURN INSTRUCTIONS

;RETURN INSTRUCTIONS,EG:	RETE	LT

.MACRO	.$.$.$	A,B
 .MACRO	A	X
  .$.CON	X,ERROR
  .BYTE	B + ...CON
 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	RETE,		0Q64	;RETURN FROM SUBROUTINE, CONDITIONAL
.$.$.$	RETC,		0Q24	;RETURN FROM SUBROUTINE AND ENABLE INTERRUPT, CONDITIONAL

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	RELATIVE ADDRESS REGISTER INSTRUCTIONS

;RELATIVE ADDRESS REGISTER,EG:	BIRR	R2,(@,)REL

.MACRO	.$.$.$	A,B
 .MACRO	A	X,Y,Z
  .NARG	...NARG		;HOW MANY ARGUMENTS?
  ...IND = 0Q0
  ...REL = 0Q0
  .$.REG	X,ERROR

  .IIF LE,...NARG-0Q1	.ERROR	1	;MISSING ARGUMENT(S)

  .IF EQ,...NARG-0Q2	;TWO ARGUMENTS, HENCE DIRECT REFERENCE
   .$.REL	Y
  .ENDIF

  .IF EQ,...NARG-0Q3	;THREE ARGUMENTS, HENCE INDIRECT REFERENCE
   .$.IND	Y,ERROR
   .$.REL	Z
  .ENDIF

  .BYTE B + ...REG,...REL + ...IND

 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEEL	MNEMONIC	OP CODE
.$.$.$	LODR,		0Q10	;LOAD RELATIVE
.$.$.$	STRR,		0Q310	;STORE RELATIVE
.$.$.$	ADDR,		0Q210	;ADD RELATIVE W/WO CARRY
.$.$.$	SUBR,		0Q250	;SUBTRACT RELATIVE W/WO BORROW
.$.$.$	ANDR,		0Q110	;AND RELATIVE
.$.$.$	IORR,		0Q150	;INCLUSIVE OR RELATIVE
.$.$.$	EORR,		0Q50	;EXCLUSIVE OR RELATIVE
.$.$.$	COMR,		0Q350	;COMPARE RELATIVE ARITHMETIC/LOGICAL
.$.$.$	CMPR,		0Q350	;COMPARE RELATIVE ARITHMETIC/LOGICAL
.$.$.$	BIRR,		0Q330	;BRANCH ON INCREMENTING REGISTER, RELATIVE
.$.$.$	BDRR,		0Q370	;BRANCH ON DECREMENTING REGISTER, RELATIVE
.$.$.$	BRNR,		0Q130	;BRANCH ON REGISTER NON-ZERO RELATIVE
.$.$.$	BSNR,		0Q170	;BRANCH ON REGISTER NON-ZERO TO SUBROUTINE RELATIVE

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	THREE BYTE INSTRUCTIONS

;THREE BYTE INSTRUCTIONS,EG:	LODA	R0,(@,)ADDRESS(,R1+)

.MACRO	.$.$.$	A,B
 .MACRO	A	W,X,Y,Z
  .NARG	...NARG	;HOW MANY ARGUMENTS
  ...IND = 0Q0
  ...IDX = 0Q0
  .$.REG	W,ERROR

  .IIF LE,...NARG-0Q1	.ERROR	1	;MISSING ARGUMENT(S)

  .$.IND	X
  .IF EQ,...IND-0Q200
   .NVAL	...A,Y
   .IIF	EQ,...NARG-0Q4	.$.REGIDX	Z
  .ELSE
   .NVAL	...A,X
   .IIF	EQ,...NARG-0Q3	.$.REGIDX	Y
  .ENDIF

  ...A = ...A + ((...IND + ...IDX) << 8)
  .BYTE	B + ...REG,>...A,<...A

 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	LODA,		0Q14	;LOAD ABSOLUTE
.$.$.$	ADDA,		0Q214	;ADDD ABSOLUTE W/WO CARRY
.$.$.$	STRA,		0Q314	;STORE ABSOLUTE
.$.$.$	SUBA,		0Q254	;SUBTRACT ABSOLUTE W/WO BORROW
.$.$.$	ANDA,		0Q114	;AND ABSOLUTE
.$.$.$	IORA,		0Q154	;INCLUSIVE OR ABSOLUTE
.$.$.$	EORA,		0Q54	;EXCLUSIVE OR ABSOLUTE
.$.$.$	COMA,		0Q354	;COMPARE ABSOLUTE ARITHMETIC/LOGICAL
.$.$.$	CMPA,		0Q354	;COMPARE ABSOLUTE ARITHMETIC/LOGICAL

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	ZERO BRANCH INSTRUCTIONS

;ZERO BRANCH INSTRUCTIONS,EG:	ZBSR	(@,)ADDRESS

.MACRO	.$.$.$	A,B
 .MACRO	A	X,Y
  .NARG	...NARG		;HOW MANY ARGUMENTS?
  ...REL = 0Q0
  ...IND = 0Q0

  .IIF EQ,...NARG	.ERROR	1	;MISSING ARGUMENT(S)

  .IF EQ,...NARG-0Q1	;DIRECT REFERENCE
   .$.REL	X
  .ENDIF

  .IF EQ,...NARG-0Q2	;INDIRECT REFERENCE
   .$.IND	X,ERROR
   .$.REL	Y
  .ENDIF

  .BYTE	B,...REL + ...IND

 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	ZBSR,		0Q273	;ZERO BRANCH TO SUBROUTINE RELATIVE, UNCONDITIONAL
.$.$.$	ZBRR,		0Q233	;ZERO BRANCH RELATIVE, UNCONDITIONAL

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	TWO BYTE BRANCH CONDITIONALLY RELATIVE

;TWO BYTE BRANCH CONDITIONALLY RELATIVE,EG:	BCTR	(EQ,)(@,)ADDRESS

.MACRO	.$.$.$	A,B
 .MACRO	A	X,Y,Z
  .NARG	...NARG		;HOW MANY ARGUMENTS?
   ...REL = 0Q0
   ...CON = 0Q3
   ...IND = 0Q0

  .IIF EQ,...NARG	.ERROR	1	;MISSING ARGUMENT(S)

  .IF EQ,...NARG-0Q1	;ONE ARGUMENT
   .$.REL	X
  .ENDIF

  .IF EQ,...NARG-0Q2	;TWO ARGUMENTS
   .$.REL	Y
   .$.CON	X
   .IF	LT,...CON
    .$.IND	X,ERROR
   .ENDIF
  .ENDIF

  .IF EQ,...NARG-0Q3	;THREE ARGUMENTS
   .$.REL	Z
   .$.CON	X,ERROR
   .$.IND	Y,ERROR
  .ENDIF

  .BYTE	B + ...CON,...REL + ...IND

 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	BCTR,		0Q30	;BRANCH ON CONDITION TRUE, RELATIVE
.$.$.$	BCFR,		0Q230	;BRANCH ON CONDITION FALSE, RELATIVE
.$.$.$	BSFR,		0Q270	;BRANCH TO SUBROUTINE ON CONDITION FALSE, RELATIVE
.$.$.$	BSTR,		0Q70	;BRANCH TO SUBROUTINE ON CONDITION TRUE, RELATIVE

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	THREE BYTE BRANCH CONDITIONALLY ABSOLUTE

;THREE BYTE BRANCH CONDITIONALLY ABSOLUTE,EQ:	BCTA	(EQ,)(@,)ADDRESS

.MACRO	.$.$.$	A,B
 .MACRO	A	X,Y,Z
  .NARG ...NARG		;HOW MANY ARGUMENTS?
   ...A = 0Q0
   ...CON = 0Q3
   ...IND = 0Q0

  .IIF EQ,...NARG	.ERROR	1	;MISSING ARGUMENT(S)

  .IF EQ,...NARG-0Q1	;ONE ARGUMENT
   .NVAL	...A,X
  .ENDIF

  .IF EQ,...NARG-0Q2	;TWO ARGUMENTS
   .NVAL	...A,Y
   .$.CON	X
   .IF	LT,...CON
    .$.IND	X,ERROR
   .ENDIF
  .ENDIF

  .IF EQ,...NARG-0Q3	;THREE ARGUMENTS
   .NVAL	...A,Z
   .$.CON	X,ERROR
   .$.IND	Y,ERROR
  .ENDIF

  ...A = (...A & 0Q077777) + (...IND << 8)
  .BYTE	B + ...CON,>...A,<...A

 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	BCTA,		0Q34	;BRANCH ON CONDITION TRUE, ABSOLUTE
.$.$.$	BCFA,		0Q234	;BRANCH ON CONDITION FALSE, ABSOLUTE
.$.$.$	BSTA,		0Q74	;BRANCH TO SUBROUTINE ON CONDITION TRUE, ABSOLUTE
.$.$.$	BSFA,		0Q274	;BRANCH TO SUBROUTINE ON CONDITION FALSE, ABSOLUTE

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	THREE BYTE REGISTER BRANCHES

;THREE BYTE REGISTER BRANCHES,EG:	BIRA	R2,(@,)ADDRESS

.MACRO	.$.$.$	A,B
 .MACRO	A	X,Y,Z
  .NARG ...NARG		;HOW MANY ARGUMENTS?
   ...A = 0Q0
   ...REG = 0
   ...IND = 0Q0

  .IIF LE,...NARG-0Q1	.ERROR	1	;MISSING ARGUMENT(S)

  .IF EQ,...NARG-0Q2	;TWO ARGUMENTS
   .NVAL	...A,Y
   .$.REG	X,ERROR
  .ENDIF

  .IF EQ,...NARG-0Q3	;THREE ARGUMENTS
   .NVAL	...A,Z
   .$.REG	X,ERROR
   .$.IND	Y,ERROR
  .ENDIF

  ...A = (...A & 0Q077777) + (...IND << 8)
  .BYTE B + ...REG,>...A,<...A

 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	BIRA,		0Q334	;BRANCH ON INCREMENTING REGISTER,ABSOLUTE
.$.$.$	BDRA,		0Q374	;BRANCH ON DECREMENTING REGISTER, ABSOLUTE
.$.$.$	BRNA,		0Q134	;BRANCH ON REGISTER NON-ZERO, ABSOLUTE
.$.$.$	BSNA,		0Q174	;BRANCH TO SUBROUTINE ON NON-ZERO REGISTER, ABSOLUTE

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.PAGE
.IIF	DEF,.$$.LIST	.SBTTL	BRANCH INDEXED ABSOLUTE

;BRANCH INDEXED ABSOLUTE (MUST BE R3 OR R7),EG:	BXA	(@,)ADDRESS,R3

.MACRO	.$.$.$	A,B
 .MACRO	A	X,Y,Z
  .NARG	...NARG
  ...A = 0Q0
  ...IND = 0Q0

  .IIF LE,...NARG-0Q1	.ERROR	1	;MISSING ARGUMENT(S)

  .IF EQ,...NARG-0Q2	;DIRECT REFERENCE?
   .NVAL	...A,X
   .$.REG	Y,ERROR
   .IIF	NE,...REG-0Q3	.ERROR	1	;MUST BE R3
  .ENDIF

  .IF EQ,...NARG-0Q3	;INDIRECT REFERENCE
   .$.IND	X,ERROR
   .NVAL	...A,Y
   .$.REG	Z,ERROR
   .IIF	NE,...REG-0Q3	.ERROR	1	;MUST BE R3
  .ENDIF

  ...A = (...A & 0Q077777) + (...IND << 8)
  .BYTE B,>...A,<...A

 .ENDM	;Instruction
.ENDM	;.$.$.$

;LABEL	MNEMONIC	OP CODE
.$.$.$	BXA,		0Q237	;BRANCH INDEXED ABSOLUTE, UNCONDITIONAL
.$.$.$	BSXA,		0Q277	;BRANCH TO SUBROUTINE, INDEXED, ABSOLUTE, UNCONDITIONAL

.MDELETE	.$.$.$

.IIF	DEF,.$$.LIST	.LIST		;LIST PROGRAM PROPER
.IIF	DEF,.$$.LIST	.PAGE
.ENDIF
